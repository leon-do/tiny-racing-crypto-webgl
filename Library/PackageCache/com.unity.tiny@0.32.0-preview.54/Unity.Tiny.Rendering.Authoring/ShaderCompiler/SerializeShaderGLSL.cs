using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Unity.Assertions;

namespace Unity.Tiny.ShaderCompiler
{
    static class SerializeShaderGLSL
    {
        internal static void Serialize(CompiledShaderData compiled, string name, bool gles2, ref byte[] serializedVert, ref byte[] serializedFrag)
        {
            ExtractShaderStages(compiled, gles2, name, out CompiledShaderData compiledVert, out CompiledShaderData compiledFragm);
            serializedVert = CreateSerializedBgfxShader(compiledVert, Stage.Vertex);
            serializedFrag = CreateSerializedBgfxShader(compiledFragm, Stage.Fragment);
        }

        /// <remarks>
        /// Matches output file generated by shaderc
        /// </remarks>
        static byte[] CreateSerializedBgfxShader(CompiledShaderData compiled, Stage stage)
        {
            using (var ms = new MemoryStream())
            using (var bw = new BinaryWriter(ms))
            {
                bool isVertexShader = stage == Stage.Vertex;

                // Header
                bw.Write(isVertexShader ? BgfxHelper.BGFX_CHUNK_MAGIC_VSH : BgfxHelper.BGFX_CHUNK_MAGIC_FSH);

                // Input/output hashes used for validating that vertex output matches fragment input
                bw.Write(0u);
                bw.Write(0u);

                SerializeUniforms(compiled, bw, stage);

                bw.Write((uint)compiled.shader.outputCode.Length);
                bw.Write(compiled.shader.outputCode);
                byte nul = 0;
                bw.Write(nul);

                return ms.ToArray();
            }
        }

        static void SerializeUniforms(CompiledShaderData compiled, BinaryWriter writer, Stage stage)
        {
            if (compiled.constantBuffers.Count == 0 && compiled.samplers.Count == 0)
            {
                writer.Write((ushort)0);
                return;
            }

            uint fragmentBit = stage == Stage.Fragment ? BgfxHelper.BGFX_UNIFORM_FRAGMENTBIT : 0u;
            var uniformsCount = compiled.samplers.Count;
            foreach (var constantBuffer in compiled.constantBuffers)
            {
                uniformsCount += constantBuffer.constants.Count;
            }
            writer.Write((ushort)uniformsCount);

            foreach(var constantBuffer in compiled.constantBuffers)
            {
                foreach (var constant in constantBuffer.constants)
                {
                    writer.Write((byte)constant.name.Length);
                    writer.Write(Encoding.UTF8.GetBytes(constant.name));

                    if (constant.dataType != UnityHelper.ShaderParamType.kShaderParamFloat)
                        throw new NotSupportedException("Only float types are supported for uniforms.");

                    // Data type
                    var type = UnityToBgfx.GetBgfxUniformDataType(constant);
                    writer.Write((byte)((uint)type | fragmentBit));

                    //  array size
                    int arraySize = Math.Max(constant.arraySize, 1); // Unity passes a 0 if not an array
                    writer.Write((byte)arraySize);

                    // regIndex is not used for GL
                    writer.Write((ushort)0);

                    // regCount
                    writer.Write((ushort)arraySize);

                    // Unused
                    writer.Write((byte)0); // texComponent
                    writer.Write((byte)0); // texDimension
                }
            }

            foreach (var sampler in compiled.samplers)
            {
                writer.Write((byte)sampler.name.Length);
                writer.Write(Encoding.UTF8.GetBytes(sampler.name));
                writer.Write((byte)((ushort)BgfxHelper.UniformType.Sampler | BgfxHelper.BGFX_UNIFORM_SAMPLERBIT | fragmentBit));

                // array size
                int arraySize = Math.Max(sampler.arraySize, 1);
                writer.Write((byte)arraySize);

                // regIndex
                writer.Write((ushort)0);

                // regCount
                writer.Write((ushort)arraySize);

                // texComponent
                writer.Write((byte)0);

                // texDimension
                writer.Write((byte)0);
            }
        }

        static void ExtractShaderStages(
            CompiledShaderData compiled,
            bool gles2,
            string name,
            out CompiledShaderData compiledVertex,
            out CompiledShaderData compiledFragment)
        {
            var src = Encoding.UTF8.GetString(compiled.shader.outputCode, 0, compiled.shader.outputCode.Length);
            ExtractShaderStage(src, "VERTEX", out string vertSrc, out string remainder);
            ExtractShaderStage(remainder, "FRAGMENT", out string fragSrc, out string remainder2);
            Assert.IsTrue(remainder2.Equals(string.Empty));
            compiledVertex = FixupShader(vertSrc, Stage.Vertex, gles2, name, compiled.attributes);
            compiledFragment = FixupShader(fragSrc, Stage.Fragment, gles2, name, null);
        }

        /// <remarks>
        /// See GLSLUtilities.cpp
        /// </remarks>
        static void ExtractShaderStage(string src, string stageStr, out string stageSrc, out string remainder)
        {
            using (StringReader reader = new StringReader(src))
            using (StringWriter writer = new StringWriter())
            {
                int ifdefCount = 0;
                while (reader.Peek() >= 0)
                {
                    var line = reader.ReadLine();
                    if (line.Contains($"#ifdef {stageStr}"))
                    {
                        ifdefCount++;
                        break;
                    }
                }

                if (ifdefCount == 0)
                {
                    stageSrc = src;
                    remainder = null;
                    return;
                }

                while (reader.Peek() >= 0)
                {
                    var line = reader.ReadLine();
                    if (line.Contains("#if ") || line.Contains("#ifdef "))
                    {
                        ifdefCount++;
                    }

                    if (line.Contains("#endif"))
                    {
                        ifdefCount--;
                        if (ifdefCount == 0)
                            break;
                    }

                    writer.WriteLine(line);
                }

                if (ifdefCount != 0)
                    throw new InvalidDataException("SerializeShaderGLSL: Could not extract shader stage from source string.");

                stageSrc = writer.ToString();
                remainder = reader.ReadToEnd();
            }
        }

        static CompiledShaderData FixupShader(string shaderSrc, Stage stage, bool GLES2, string name, List<UnityHelper.ShaderChannel> attributes)
        {
            List<VarName> predefinedUniforms = new List<VarName>();
            List<VarName> hlslccUniforms = new List<VarName>();
            List<VarName> attributesNames = new List<VarName>();
            List<string> shadowSamplers = new List<string>();
            List<Constant> constants = new List<Constant>();
            CompiledShaderData shaderData = new CompiledShaderData();
            shaderData.Init();
            if (attributes != null)
                shaderData.attributes = attributes;

            using (StringReader reader = new StringReader(shaderSrc))
            {
                while (reader.Peek() >= 0)
                {
                    var line = reader.ReadLine();
                    if (Regex.IsMatch(line, @"^\s*(\buniform\b|UNITY_LOCATION\s*\(\s*[0-9]\s*\)\s+\buniform\b)")) // starts with word 'uniform' or 'UNITY_LOCATION(<index>) uniform', ignoring leading whitespace
                    {
                        ProcessUniformDecl(line, predefinedUniforms, hlslccUniforms, shadowSamplers, constants, shaderData.samplers);
                    }
                    else if (Regex.IsMatch(line, @"^\s*(\bUNITY_BINDING\b\s*\(\s*[0-9]\s*\)\s+\buniform\b)")) // starts with word 'UNITY_BINDING(<index>) uniform', ignoring leading whitespace
                    {
                        UnityEngine.Debug.LogWarning($"Uniform buffer object found in GLSL shader {name}. Use 'CBUFFER_START' and 'CBUFFER_END' macros in place of raw cbuffer declarations.");
                    }
                    else if (stage == Stage.Vertex && Regex.IsMatch(line, @"^\s*\b(in|attribute)\b")) // starts with word 'in' or 'attribute', ignoring leading whitespaceS 
                    {
                        // e.g. "in vec4 in_POSITION0;"
                        var split = line.Split(null);
                        string unityName = split[split.Length - 1].Remove(split[split.Length - 1].Length - 1, 1); // remove semicolon
                        UnityHelper.ShaderChannel channel = UnityHelper.ConvertHLSLccAttributeName(unityName);
                        Assert.IsTrue(shaderData.attributes.Contains(channel));
                        BgfxHelper.Attrib bgfxAttrib = UnityToBgfx.ConvertAttribute(channel);
                        attributesNames.Add(new VarName { unityName = unityName, bgfxName = BgfxHelper.GetName(bgfxAttrib) });
                    }
                }
            }

            // Disable UBO and Uniform Locations
            shaderSrc = shaderSrc.Replace("#define HLSLCC_ENABLE_UNIFORM_BUFFERS 1", string.Empty);
            shaderSrc = shaderSrc.Replace("#define UNITY_SUPPORTS_UNIFORM_LOCATION 1", string.Empty);

            using (StringReader reader = new StringReader(shaderSrc))
            using (StringWriter writer = new StringWriter())
            {
                // Remove everything before the '#version' line because bgfx looks for this when determining if it needs to inject the version
                while (reader.Peek() >= 0)
                {
                    var line = reader.ReadLine();
                    if (line.StartsWith("#version "))
                    {
                        writer.WriteLine(line);
                        break;
                    }
                }

                // Why doesn't HLSLcc handle this?
                // Note: this isn't needed if matrix as vectors is enabled
                if (GLES2)
                {
                    writer.WriteLine("#define mat2x2 mat2");
                    writer.WriteLine("#define mat3x3 mat3");
                    writer.WriteLine("#define mat4x4 mat4");
                }

                // inject fixups for uniform and attribute names after the version
                foreach (var uniform in predefinedUniforms)
                {
                    // e.g. #define unity_ObjectToWorld u_model
                    writer.WriteLine($"#define {uniform.unityName} {uniform.bgfxName}");
                }
                foreach (var uniform in hlslccUniforms)
                {
                    writer.WriteLine($"#define {uniform.unityName} {uniform.bgfxName}");
                }

                // Note this shouldn't modify the vertex output because the names are unique
                foreach (var attribute in attributesNames)
                {
                    // e.g. #define in_POSITION0 a_position
                    writer.WriteLine($"#define {attribute.unityName} {attribute.bgfxName}");
                }

                while (reader.Peek() >= 0)
                {
                    var line = reader.ReadLine();

                    if (Regex.IsMatch(line, @"^\s*(\buniform\b|UNITY_LOCATION\s*\(\s*[0-9]\s*\)\s+\buniform\b)")) // starts with word 'uniform' or 'UNITY_LOCATION(<index>) uniform', ignoring leading whitespace
                    {
                        // Remove duplicate sampler created for shadow texture
                        // HLSLcc creates a shadow sampler and a regular sampler which results in issues when using the sampler names to bind them
                        if (shadowSamplers.Any(samplerName => Regex.IsMatch(line, $@"\b{samplerName}\b")))
                            continue;

                        PatchPredefinedUniformDecl(predefinedUniforms, ref line);
                    }

                    // Remove comments
                    if (Regex.IsMatch(line, @"^\s*//"))
                        continue;

                    writer.WriteLine(line);
                }

                string newSrc = writer.ToString();
                shaderData.shader = new CompiledShader { outputCode = Encoding.UTF8.GetBytes(newSrc) };
                shaderData.constantBuffers.Add(new ConstantBuffer { constants = constants });
                return shaderData;
            }
        }

        static void ProcessUniformDecl(string line, List<VarName> predefinedUniforms, List<VarName> hlslccUniforms, List<string> shadowSamplers, List<Constant> constants, List<TextureSampler> samplers)
        {
            // e.g. "uniform mat4x4 uniformName;"
            // e.g. "uniform sampler2D samplerName;"
            var split = line.Split((char[])null, StringSplitOptions.RemoveEmptyEntries);
            if (split.Length < 3) // "uniform <type> <name>;"
                throw new InvalidDataException($"SerializeShaderGLSL: Unable to parse uniform declaration '{line}'");

            // Unity shader compiler does not give reflection data for uniforms in all cases so we generate it manually
            string name = split[split.Length - 1].Remove(split[split.Length - 1].Length - 1, 1); // remove semicolon
            int arraySize = 0;
            var i = name.IndexOf('['); // e.g. "uniformName[4];"
            if (i >= 0)
            {
                string pattern = @".*\[([0-9]+)\]"; // Capture number between brackets in a separate group
                var match = Regex.Match(name, pattern);
                if (match.Groups.Count != 2)
                    throw new InvalidDataException("SerializeShaderGLSL: Unable to parse array declaration.");
                arraySize = int.Parse(match.Groups[1].Value);

                name = name.Substring(0, i); // remove array brackets from name
            }

            bool mtxAsVectors = name.StartsWith(UnityToBgfx.k_HlslccMtxPrefix);
            if (UnityToBgfx.ConvertBuiltInUniform(name, out var bgfxName))
            {
                predefinedUniforms.Add(new VarName { unityName = name, bgfxName = bgfxName });
            }
            else
            {
                // TODO fix and expose HLSLCC_FLAG_TRANSLATE_MATRICES flag
                if (mtxAsVectors) // e.g. "hlslcc_mtx4x4uniformName"
                {
                    bgfxName = name.Remove(0, UnityToBgfx.k_HlslccMtxPrefix.Length);
                    hlslccUniforms.Add(new VarName { unityName = name, bgfxName = bgfxName });
                }
                else if (name.StartsWith(UnityToBgfx.k_HlslccZcmpPrefix)) // e.g. "hlslcc_zcmpsamplerName"
                {
                    bgfxName = name.Remove(0, UnityToBgfx.k_HlslccZcmpPrefix.Length);
                    hlslccUniforms.Add(new VarName { unityName = name, bgfxName = bgfxName });
                    shadowSamplers.Add(bgfxName);
                }
                else
                {
                    bgfxName = name;
                }
            }

            string type = split[split.Length - 2];
            if (type.Contains("sampler"))
            {
                samplers.Add(GetTextureSampler(bgfxName, arraySize));
            }
            else
            {
                constants.Add(GetConstant(type, bgfxName, arraySize, mtxAsVectors));
            }
        }

        static TextureSampler GetTextureSampler(string name, int arraySize)
        {
            return new TextureSampler { name = name, arraySize = arraySize };
        }

        static Constant GetConstant(string type, string name, int arraySize, bool mtxAsVectors)
        {
            // For mat4x4's that have been converted to vec4 arrays, we serialize mat4x4 reflection data so bgfx doesn't give a type mismatch error when we create the uniform.
            // This abuses the fact that bgfx uses the reflection data from the compiled shader instead of what is in the serialized shader data to know which GL type to bind for custom uniforms.
            // TODO mtx3x3
            if (mtxAsVectors)
            {
                return new Constant
                {
                    name = name,
                    dataType = UnityHelper.ShaderParamType.kShaderParamFloat,
                    constantType = UnityHelper.ConstantType.kConstantTypeMatrix,
                    rows = 4,
                    cols = 4,
                    arraySize = arraySize / 4
                };
            }

            UnityHelper.ConstantType constantType;
            int rows, cols;

            // See https://bkaradzic.github.io/bgfx/bgfx.html#_CPPv4N4bgfx11UniformTypeE
            switch (type)
            {
                case "vec4":
                    constantType = UnityHelper.ConstantType.kConstantTypeDefault;
                    rows = 1;
                    cols = 4;
                    break;
                case "mat4":
                case "mat4x4":
                    constantType = UnityHelper.ConstantType.kConstantTypeMatrix;
                    rows = 4;
                    cols = 4;
                    break;
                case "mat3":
                case "mat3x3":
                    // TODO
//                    constantType = UnityHelper.ConstantType.kConstantTypeMatrix;
//                    rows = 3;
//                    cols = 3;
                    throw new InvalidDataException("SerializeShaderGLSL: Matrix 3x3 is currently not supported for uniforms. Please use a Matrix 4x4.");
                default:
                    throw new InvalidDataException($"SerializeShaderGLSL: Unsupported uniform type '{type}'. Supported types are vec4, mat4x4, and mat3x3");
            }

            return new Constant
            {
                name = name,
                dataType = UnityHelper.ShaderParamType.kShaderParamFloat,
                constantType = constantType,
                rows = rows,
                cols = cols,
                arraySize = arraySize
            };
        }

        static void PatchPredefinedUniformDecl(List<VarName> predefinedUniforms, ref string decl)
        {
            // e.g. "uniform vec4 uniformName[4];"
            var split = decl.Split((char[])null, StringSplitOptions.RemoveEmptyEntries);
            string unityName = split[split.Length - 1].Remove(split[split.Length - 1].Length - 1, 1); // remove semicolon
            var i = unityName.IndexOf('[');
            unityName = i >= 0 ? unityName.Substring(0, i) : unityName; // remove array brackets

            // TODO fix and expose HLSLCC_FLAG_TRANSLATE_MATRICES flag
            // Convert vec4 arrays back to mat4x4's for predefined matrix uniforms
            // This is only an issue for predefined uniforms because Bgfx assumes their type, unlike custom uniforms where the type is determined from the compiled shader's reflection data at runtime.
            // This works because indexing into a mat4x4 is the same as indexing into a vec4[4]. This would not work when indexing into a matrix array that was converted to a vector array,
            // but there are no common predefined uniforms in Unity and Bgfx that are matrix arrays.

            // This is a hack to get around HLSLcc converting all matrices to vector arrays as an optimization.
            // The better solution would be to expose the HLSLCC_FLAG_TRANSLATE_MATRICES flag in the Unity shader compiler but this code path is not well tested - if HLSLCC_FLAG_TRANSLATE_MATRICES is disabled
            // then HLSLcc generates invalid GLES2 shader code that can not be trivially fixed due to GLES2 not supporting the modulo operator or dynamic array indexes in shaders.
            if (unityName.StartsWith(UnityToBgfx.k_HlslccMtxPrefix) && predefinedUniforms.Any(uniform => uniform.unityName.Equals(unityName)))
            {
                decl = $"uniform \tmat4x4 {unityName};";
            }
        }
    }
}
