using System;
using System.IO;
using System.Text;

namespace Unity.Tiny.ShaderCompiler
{
    static class SerializeShaderHLSL
    {
        internal static void Serialize(CompiledShaderData vert, CompiledShaderData frag, string name, ref byte[] serializedVert, ref byte[] serializedFrag)
        {
            serializedVert = CreateSerializedBgfxShader(vert, Stage.Vertex);
            serializedFrag = CreateSerializedBgfxShader(frag, Stage.Fragment);
        }

        /// <remarks>
        /// Matches output file generated by shaderc
        /// </remarks>
        static byte[] CreateSerializedBgfxShader(CompiledShaderData compiled, Stage stage)
        {
            // Strip root signature from shader blob and fix constant buffer bindings
            int index = 0;
            const int kD3DRootSignatureHeaderSize = 5;
            if (compiled.shader.outputCode[index] != 0)
            {
                index++;
                index += kD3DRootSignatureHeaderSize;
            }
            else
            {
                index++;
            }

            if (index >= compiled.shader.outputCode.Length)
            {
                throw new Exception("D3D shader bytecode missing from blob!");
            }

            byte[] stripped = new byte[compiled.shader.outputCode.Length - index];
            Array.Copy(compiled.shader.outputCode, index, stripped, 0, stripped.Length);
            byte[] shader = DXBCHelper.PatchConstantBuffersAndTextures(stripped, compiled.texToSampler);

            // Export bgfx file
            using (var ms = new MemoryStream())
            using (var bw = new BinaryWriter(ms))
            {
                // Header
                bw.Write(GetBgfxHeader(compiled.shader.type));

                // Input/output hashes used for validating that vertex output matches fragment input
                bw.Write(0u);
                bw.Write(0u);

                var uniformBufferSize = SerializeUniforms(compiled, bw, stage);

                bw.Write((uint)shader.Length);
                bw.Write(shader);
                byte nul = 0;
                bw.Write(nul);

                // Attributes
                if (compiled.shader.type == UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX11VertexSM40 || compiled.shader.type == UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX11VertexSM50 ||
                    compiled.shader.type == UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX11PixelSM40 || compiled.shader.type == UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX11PixelSM50)
                {
                    // vertex attributes
                    bw.Write((byte)compiled.attributes.Count);
                    foreach (var attribute in compiled.attributes)
                    {
                        BgfxHelper.Attrib attrib = UnityToBgfx.ConvertAttribute(attribute);
                        bw.Write(BgfxHelper.s_AttribToId[attrib]);
                    }

                    // constant buffer size
                    bw.Write(uniformBufferSize);
                }

                return ms.ToArray();
            }
        }

        static uint SerializeUniforms(CompiledShaderData compiled, BinaryWriter writer, Stage stage)
        {
            if (compiled.constantBuffers.Count == 0 && compiled.samplers.Count == 0)
            {
                writer.Write((ushort)0);
                return 0;
            }

            uint fragmentBit = stage == Stage.Fragment ? BgfxHelper.BGFX_UNIFORM_FRAGMENTBIT : 0u;
            var uniformsCount = compiled.samplers.Count;
            foreach (var constantBuffer in compiled.constantBuffers)
            {
                uniformsCount += constantBuffer.constants.Count;
            }
            writer.Write((ushort)uniformsCount);

            uint globalConstantBufferSize = 0;
            foreach (var constantBuffer in compiled.constantBuffers)
            {
                uint constantBufferSize = 0;
                foreach (var constant in constantBuffer.constants)
                {
                    UnityToBgfx.ConvertBuiltInUniform(constant.name, out string uniformName);
                    writer.Write((byte)uniformName.Length);
                    writer.Write(Encoding.UTF8.GetBytes(uniformName));
                
                    if (constant.dataType != UnityHelper.ShaderParamType.kShaderParamFloat)
                        throw new NotSupportedException("Only float types are supported for uniforms.");
                
                    // Data type
                    uint parameterSize;
                    var type = UnityToBgfx.GetBgfxUniformDataType(constant);
                    writer.Write((byte)((uint)type | fragmentBit));
                    if (type == BgfxHelper.UniformType.Vec4)
                    {
                        parameterSize = 16;
                    }
                    else if (type == BgfxHelper.UniformType.Mat4)
                    {
                        parameterSize = 64;
                    }
                    else
                    {
                        // bgfx.UniformType.Mat3. Size includes padding
                        parameterSize = 44;
                    }
                
                    // array size
                    writer.Write((byte)constant.arraySize); // Should be 0 if not an array

                    // regIndex - merge all constants into a single buffer
                    writer.Write((ushort)(globalConstantBufferSize + constant.idx));
                
                    // regCount
                    parameterSize = constant.arraySize > 0 ? parameterSize * (uint)constant.arraySize : parameterSize;
                    parameterSize = AlignUp(parameterSize, 16);
                    writer.Write((ushort)(parameterSize / 16));

                    // Unused
                    writer.Write((byte)0); // texComponent
                    writer.Write((byte)0); // texDimension

                    // Actual size of this constant buffer. All unused constants after the last used constant are removed
                    constantBufferSize = (uint)constant.idx + parameterSize;
                }

                globalConstantBufferSize += constantBufferSize;
            }

            foreach (var sampler in compiled.samplers)
            {
                writer.Write((byte)sampler.name.Length);
                writer.Write(Encoding.UTF8.GetBytes(sampler.name));
                writer.Write((byte)((ushort)BgfxHelper.UniformType.Sampler | BgfxHelper.BGFX_UNIFORM_SAMPLERBIT | fragmentBit));

                // array size
                writer.Write((byte)sampler.arraySize); // this will always be zero

                // regIndex
                writer.Write((ushort)sampler.register);

                // regCount
                writer.Write((ushort)1);

                // Unused
                writer.Write((byte)0); // texComponent
                writer.Write((byte)0); // texDimension
            }

            return globalConstantBufferSize;
        }

        static uint GetBgfxHeader(UnityHelper.ShaderGpuProgramType programType)
        {
            switch (programType)
            {
                case UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX9VertexSM20_Removed:
                case UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX9VertexSM30_Removed:
                case UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX10Level9Vertex_Removed:
                case UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX11VertexSM40:
                case UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX11VertexSM50:
                    return BgfxHelper.BGFX_CHUNK_MAGIC_VSH;
                case UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX9PixelSM20_Removed:
                case UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX9PixelSM30_Removed:
                case UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX10Level9Pixel_Removed:
                case UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX11PixelSM40:
                case UnityHelper.ShaderGpuProgramType.kShaderGpuProgramDX11PixelSM50:
                    return BgfxHelper.BGFX_CHUNK_MAGIC_FSH;
                default:
                    throw new NotSupportedException($"{nameof(programType)} is not a valid HLSL shader type.");
            }
        }

        static uint AlignUp(uint value, uint alignment)
        {
            return (value + (alignment - 1)) & ~(alignment - 1);
        }
    }
}
